"""V2 Profile Memory data type definitions.

Main differences from V1:
1. Separation of explicit information and implicit traits
2. Flexible categorization (fields are not fixed)
3. Simplified evidence format
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional

from api_specs.memory_types import BaseMemory, MemoryType, MemCell
from memory_layer.memory_extractor.base_memory_extractor import MemoryExtractRequest


@dataclass
class ExplicitInfo:
    """Explicit information - Facts directly stated by the user."""
    
    category: str  # Category (e.g. health status, diet preferences, exercise preferences)
    description: str  # One-sentence description
    evidence: str = ""  # One-sentence evidence (generated by LLM based on conversation)
    sources: List[str] = field(default_factory=list)  # Source episode_id list
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "category": self.category,
            "description": self.description,
            "evidence": self.evidence,
            "sources": self.sources,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ExplicitInfo":
        return cls(
            category=data.get("category", ""),
            description=data.get("description", ""),
            evidence=data.get("evidence", "") or "",
            sources=data.get("sources", []),
        )


@dataclass
class ImplicitTrait:
    """Implicit trait - Deep characteristics inferred from multiple behaviors."""
    
    trait_name: str  # Trait name
    description: str  # One-sentence description
    basis: str  # Basis for inference
    evidence: str = ""  # One-sentence evidence (generated by LLM based on conversation)
    sources: List[str] = field(default_factory=list)  # Source episode_id list (multiple required)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "trait": self.trait_name,
            "description": self.description,
            "basis": self.basis,
            "evidence": self.evidence,
            "sources": self.sources,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ImplicitTrait":
        return cls(
            trait_name=data.get("trait", ""),
            description=data.get("description", ""),
            basis=data.get("basis", ""),
            evidence=data.get("evidence", "") or "",
            sources=data.get("sources", []),
        )


@dataclass
class ProfileMemoryV2(BaseMemory):
    """V2 Profile Memory - Explicit information + Implicit traits.
    
    Differences from V1 ProfileMemory:
    - V1: Fixed fields (hard_skills, soft_skills, personality...)
    - V2: Flexible explicit information list + implicit trait list
    """
    
    explicit_info: List[ExplicitInfo] = field(default_factory=list)
    implicit_traits: List[ImplicitTrait] = field(default_factory=list)
    
    # Metadata
    last_updated: Optional[datetime] = None
    processed_episode_ids: List[str] = field(default_factory=list)  # Processed episode IDs
    
    def __post_init__(self) -> None:
        self.memory_type = MemoryType.PROFILE
        if self.last_updated is None:
            self.last_updated = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        base_dict = super().to_dict()
        base_dict.update({
            "explicit_info": [info.to_dict() for info in self.explicit_info],
            "implicit_traits": [trait.to_dict() for trait in self.implicit_traits],
            "last_updated": self.last_updated.isoformat() if self.last_updated else None,
            "processed_episode_ids": self.processed_episode_ids,
        })
        return base_dict
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any], user_id: str = "", group_id: str = "") -> "ProfileMemoryV2":
        explicit_list = [
            ExplicitInfo.from_dict(d) for d in data.get("explicit_info", [])
        ]
        implicit_list = [
            ImplicitTrait.from_dict(d) for d in data.get("implicit_traits", [])
        ]
        
        last_updated = data.get("last_updated")
        if isinstance(last_updated, str):
            last_updated = datetime.fromisoformat(last_updated)
        
        return cls(
            memory_type=MemoryType.PROFILE,
            user_id=user_id or data.get("user_id", ""),
            group_id=group_id or data.get("group_id", ""),
            timestamp=datetime.now(),
            ori_event_id_list=data.get("ori_event_id_list", []),
            explicit_info=explicit_list,
            implicit_traits=implicit_list,
            last_updated=last_updated,
            processed_episode_ids=data.get("processed_episode_ids", []),
        )
    
    def total_items(self) -> int:
        """Return total number of items."""
        return len(self.explicit_info) + len(self.implicit_traits)
    
    def get_all_source_ids(self) -> set:
        """Get all referenced episode IDs."""
        ids = set()
        def _extract_id(source: str) -> str:
            if not source:
                return ""
            if "|" in source:
                return source.rsplit("|", 1)[-1].strip()
            return source.strip()

        for info in self.explicit_info:
            for s in info.sources:
                sid = _extract_id(str(s))
                if sid:
                    ids.add(sid)
        for trait in self.implicit_traits:
            for s in trait.sources:
                sid = _extract_id(str(s))
                if sid:
                    ids.add(sid)
        return ids
    
    def to_readable_document(self) -> str:
        """Generate a full readable user profile document (with evidence)."""
        lines = []
        lines.append("=" * 50)
        lines.append("User Profile Document")
        lines.append(f"Last Updated: {self.last_updated.strftime('%Y-%m-%d %H:%M') if self.last_updated else 'N/A'}")
        lines.append(f"Total {self.total_items()} items (Explicit: {len(self.explicit_info)}, Implicit: {len(self.implicit_traits)})")
        lines.append("=" * 50)
        
        if self.explicit_info:
            lines.append("\n[Explicit Info]")
            # Group by category
            categories: Dict[str, List[ExplicitInfo]] = {}
            for info in self.explicit_info:
                categories.setdefault(info.category, []).append(info)
            for cat, infos in categories.items():
                lines.append(f"  [{cat}]")
                for info in infos:
                    if info.evidence:
                        lines.append(f"    - {info.description} (evidence: {info.evidence})")
                    else:
                        lines.append(f"    - {info.description}")
        
        if self.implicit_traits:
            lines.append("\n[Implicit Traits]")
            for i, trait in enumerate(self.implicit_traits, 1):
                lines.append(f"  {i}. {trait.trait_name}")
                lines.append(f"     {trait.description}")
                lines.append(f"     - basis: {trait.basis}")
                if trait.evidence:
                    lines.append(f"     - evidence: {trait.evidence}")
        
        return "\n".join(lines)
    
    def to_readable_profile(self) -> str:
        """Generate a concise readable profile (no evidence/sources, for end users)."""
        lines = []
        
        if self.explicit_info:
            lines.append("[Explicit Info]")
            categories: Dict[str, List[ExplicitInfo]] = {}
            for info in self.explicit_info:
                categories.setdefault(info.category, []).append(info)
            for cat, infos in categories.items():
                lines.append(f"  {cat}:")
                for info in infos:
                    lines.append(f"    - {info.description}")
        
        if self.implicit_traits:
            if lines:
                lines.append("")
            lines.append("[Implicit Traits]")
            for trait in self.implicit_traits:
                lines.append(f"  - {trait.trait_name}: {trait.description}")
        
        return "\n".join(lines) if lines else "No profile data yet."


@dataclass
class ProfileMemoryV2ExtractRequest(MemoryExtractRequest):
    """V2 Profile extraction request.
    
    LLM receives 4 types of information:
    1. old_profile - Current user profile
    2. referenced_episodes - Historical conversations referenced by profile (evidence sources)
    3. cluster_episodes - Conversations in the same topic cluster (context reference)
    4. new_episode - Latest conversation record
    """
    
    # New 4 types of input
    new_episode: Optional[Dict[str, Any]] = None  # Latest memcell
    referenced_episodes: Optional[List[Dict[str, Any]]] = None  # Memcells referenced by profile
    cluster_episodes: Optional[List[Dict[str, Any]]] = None  # Memcells in same cluster
    old_profile: Optional[ProfileMemoryV2] = None  # Existing profile
    
    # Legacy fields (to be deprecated)
    memcell: Optional[MemCell] = None
    memcell_list: Optional[List[MemCell]] = None
    episode_list: Optional[List[Dict[str, Any]]] = None
    
    max_items: int = 25  # Profile item limit
    
    def __post_init__(self):
        if self.memcell_list is None:
            self.memcell_list = []
        if self.episode_list is None:
            self.episode_list = []
        if self.referenced_episodes is None:
            self.referenced_episodes = []
        if self.cluster_episodes is None:
            self.cluster_episodes = []

